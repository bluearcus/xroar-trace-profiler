<!DOCTYPE html>
<html lang="en">
<!--
  XRoar Trace Profiler - Viewer
  
  Interactive visualization tool for 6809 CPU cycle profiles
  
  Copyright (c) 2025 Mike Miller
  
  This work is licensed under a Creative Commons 
  Attribution-NonCommercial-ShareAlike 4.0 International License.
  
  See https://creativecommons.org/licenses/by-nc-sa/4.0/
  
  v0.1 19 Jan 2026 Initial release
-->
<head>
    <meta charset="UTF-8">
    <title>Xroar Trace Profile Viewer</title>
    <style>
        * { box-sizing: border-box; }
        body { 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; 
            background: #0a0a0a; color: #e0e0e0; margin: 0; 
            display: flex; flex-direction: column; height: 100vh; overflow: hidden; 
        }
        header { 
            background: #1f1f1f; padding: 0 15px; border-bottom: 1px solid #333; 
            display: flex; align-items: center; gap: 15px; flex-shrink: 0; 
            height: 52px; z-index: 20;
        }
        h1 { font-size: 13px; margin: 0; color: #4fc3f7; text-transform: uppercase; letter-spacing: 1.5px; white-space: nowrap; font-weight: 700; }
        
        .file-input-wrapper { position: relative; overflow: hidden; display: inline-block; }
        .file-input-wrapper input[type=file] { font-size: 100px; position: absolute; left: 0; top: 0; opacity: 0; cursor: pointer; }
        .btn-load { background: #2e7d32; color: #fff; border: none; padding: 6px 12px; cursor: pointer; border-radius: 3px; font-size: 10px; font-weight: 800; text-transform: uppercase; }

        #chart-outer { padding: 10px; background: #0a0a0a; display: flex; align-items: stretch; }
        #chart-container { 
            background: #000; height: 320px; flex: 1;
            position: relative; border: 1px solid #333; border-radius: 4px;
            cursor: crosshair; touch-action: none; overflow: hidden;
        }
        #y-axis-container {
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            padding: 10px 8px 20px 0;
            position: relative;
            min-width: 50px;
        }
        .y-tick-label {
            position: absolute;
            right: 8px;
            font-size: 10px;
            color: #888;
            font-family: monospace;
            text-align: right;
            line-height: 1;
            transform: translateY(-50%);
        }
        
        #table-outer { flex: 1; padding: 0 10px 10px 10px; overflow: hidden; display: flex; flex-direction: column; }
        .table-toolbar {
            background: #1f1f1f; padding: 6px 10px; border: 1px solid #333; border-bottom: none;
            display: flex; align-items: center; gap: 15px; border-radius: 4px 4px 0 0;
            font-size: 11px; color: #888;
        }
        .tool-group { display: flex; align-items: center; gap: 5px; }
        .tool-group input[type="text"] { 
            background: #000; border: 1px solid #444; color: #4fc3f7; 
            padding: 3px 6px; border-radius: 2px; font-family: monospace; font-size: 12px;
        }
        .tool-group input[type="radio"] { margin: 0 2px; }
        
        #search-status {
            color: #888;
            font-size: 11px;
            margin-left: 10px;
            font-style: italic;
        }
        #search-status.not-found { color: #ff6b6b; }
        
        #table-wrapper { 
            flex: 1; overflow-y: auto; background: #161616; 
            border: 1px solid #333; border-radius: 0 0 4px 4px;
        }
        
        table { width: 100%; border-collapse: collapse; font-family: 'Courier New', monospace; font-size: 13px; }
        th { position: sticky; top: 0; background: #252525; padding: 4px 10px; text-align: left; color: #888; border-bottom: 2px solid #444; z-index: 10; font-size: 11px; line-height: 1.2; vertical-align: top; }
        td { padding: 4px 10px; border-bottom: 1px solid #222; }
        tr:hover { background: #2a2a2a; cursor: pointer; }
        tr.selected { background-color: #0d47a1 !important; color: white; }
        tr.hover-highlight { background-color: #1a4d2e !important; }
        .hex { color: #ffca28; font-weight: bold; }
        
        .btn-group { display: flex; gap: 4px; margin-left: 5px; border-left: 1px solid #444; padding-left: 10px; }
        button.small-btn { background: #333; color: #eee; border: 1px solid #555; padding: 4px 8px; cursor: pointer; border-radius: 2px; font-size: 9px; font-weight: bold; text-transform: uppercase; }
        button.small-btn:hover { background: #444; }

        #file-summary { margin-left: auto; display: flex; gap: 15px; font-size: 11px; border-left: 1px solid #444; padding-left: 15px; align-items: center; }
        .summary-item b { color: #aaa; font-weight: bold; margin-right: 4px; font-size: 9px; text-align: right; }
        .summary-item b::after { content: ':'; }
        .summary-item span { color: #4fc3f7; font-family: monospace; }
        .summary-item { display: flex; gap: 4px; align-items: center; }

        #tooltip { position: fixed; background: rgba(0,0,0,0.95); color: #fff; padding: 8px; border: 1px solid #4fc3f7; pointer-events: none; font-size: 12px; display: none; z-index: 100; border-radius: 4px; font-family: monospace; }
        
        #help-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #666;
            font-size: 13px;
            line-height: 1.8;
            pointer-events: none;
            max-width: 400px;
        }
        #help-text.hidden { display: none; }
    </style>
</head>
<body>

<header>
    <h1>Xroar Trace Profile Viewer</h1>
    <div class="file-input-wrapper">
        <div class="btn-load">LOAD</div>
        <input type="file" id="file-selector">
    </div>
    <div class="btn-group">
        <button class="small-btn" onclick="setZoomRaw(0, 65535)">64K</button>
        <button class="small-btn" onclick="jumpToVectors()">VECT</button>
        <button class="small-btn" onclick="zoomTraced(0, 0xFFFF)">ALL</button>
        <button class="small-btn" onclick="zoomTraced(0, 0x7FFF)">LO32</button>
        <button class="small-btn" onclick="zoomTraced(0x8000, 0xFFFF)">HI32</button>
    </div>
    <div class="control-group" style="margin-left:10px;">
        <input type="checkbox" id="log-toggle" onchange="render(); renderYLabels();">
        <label for="log-toggle" style="font-size: 9px; color:#aaa; cursor:pointer;">LOG Y</label>
    </div>
    <div id="file-summary">
        <div class="summary-item"><b>FILE</b><span id="sum-name">---</span></div>
        <div class="summary-item"><b>MODIFIED</b><span id="sum-modified">---</span></div>
        <div class="summary-item"><b>TOTAL INSTRUCTIONS<br>TRACED</b><span id="sum-traced">0</span></div>
        <div class="summary-item"><b>INSTRUCTION<br>EXECUTIONS</b><span id="sum-executions">0</span></div>
        <div class="summary-item"><b>CPU CYCLES</b><span id="sum-cycles">0</span></div>
        <div class="summary-item"><b>TRACE TIME</b><span id="sum-time">0.000s</span></div>
    </div>
</header>

<div id="chart-outer">
    <div id="y-axis-container">
        <div id="y-labels"></div>
    </div>
    <div id="chart-container">
        <canvas id="mainCanvas"></canvas>
        <div id="help-text">
            Drop trace file here or click LOAD and browse to required file.<br>
            Use scrollwheel to zoom the chart, drag to pan, double-click to jump to address.
        </div>
        <div id="tooltip"></div>
    </div>
</div>

<div id="table-outer">
    <div class="table-toolbar">
        <div class="tool-group">
            GOTO: <input type="text" id="goto-addr" placeholder="Hex" size="5">
            <button class="small-btn" onclick="gotoAddress()">GO</button>
        </div>
        <div class="tool-group">
            FIND: <input type="text" id="search-str" placeholder="Instruction..." size="15">
            <button class="small-btn" onclick="doSearch()">SEARCH</button>
            <label style="cursor:pointer;"><input type="radio" name="search-dir" value="1" checked onkeydown="handleRadioKey(event)"> FWD</label>
            <label style="cursor:pointer;"><input type="radio" name="search-dir" value="-1" onkeydown="handleRadioKey(event)"> BACK</label>
            <label style="cursor:pointer;"><input type="checkbox" id="search-wrap" checked> WRAP</label>
            <span id="search-status"></span>
        </div>
    </div>
    <div id="table-wrapper">
        <table id="main-table">
            <thead>
                <tr><th width="90">ADDRESS</th><th width="160">TRACED INSTRUCTION<br>CYCLES</th><th>INSTRUCTION</th></tr>
            </thead>
            <tbody id="table-body"></tbody>
        </table>
    </div>
</div>

<script>
    const canvas = document.getElementById('mainCanvas');
    const ctx = canvas.getContext('2d');
    const tooltip = document.getElementById('tooltip');
    const logToggle = document.getElementById('log-toggle');
    const fileInput = document.getElementById('file-selector');
    const helpText = document.getElementById('help-text');
    const chartContainer = document.getElementById('chart-container');
    
    let rawData = [];
    let plotData = []; 
    let tableData = []; 
    let addrMap = {};
    let viewMin = 0, viewMax = 65535, maxCycles = 1, displayMax = 1;
    let isDragging = false, lastMouseX = 0;
    let dataLoaded = false;
    let searchIndex = -1;
    let yAxisWidth = 50;
    let currentHoverAddr = -1;
    let selectedAddr = -1;
    let searchMatches = [];

    const CPU_FREQ = 890000;
    const hexFmt = (v) => "$" + Math.max(0, Math.min(65535, Math.round(v))).toString(16).toUpperCase().padStart(4, '0');

    function resize() {
        canvas.width = canvas.parentElement.clientWidth;
        canvas.height = canvas.parentElement.clientHeight;
        render();
    }
    window.addEventListener('resize', resize);
    resize();

    function loadFile(file) {
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (f) => {
            try {
                rawData = JSON.parse(f.target.result);
                addrMap = {}; plotData = []; tableData = [];
                let localMax = 1, totalInstCycles = 0, tracedInstructions = 0, totalExecutions = 0;
                
                rawData.forEach(d => {
                    const ic = d.ic || 0;
                    const ac = d.ac || 0;
                    totalInstCycles += ic;
                    if (ic > 0) {
                        tableData.push(d);
                        tracedInstructions++;
                        
                        const match = d.ins.match(/;\s*\((\d+)\s+cycles?\)/);
                        if (match) {
                            const cyclesPerExec = parseInt(match[1]);
                            if (cyclesPerExec > 0) {
                                totalExecutions += ic / cyclesPerExec;
                            }
                        }
                    }
                    if (ac > 0) {
                        plotData.push({ a: d.a, c: ac });
                        if (ac > localMax) localMax = ac;
                    }
                    if (d.a !== undefined) addrMap[d.a] = d;
                });

                maxCycles = localMax;
                dataLoaded = true;
                helpText.classList.add('hidden');
                
                const numLabels = 6;
                function niceNumber(value) {
                    const magnitude = Math.pow(10, Math.floor(Math.log10(value)));
                    const normalized = value / magnitude;
                    let nice;
                    if (normalized < 1.5) nice = 1;
                    else if (normalized < 3) nice = 2;
                    else if (normalized < 7) nice = 5;
                    else nice = 10;
                    return nice * magnitude;
                }
                const rawInterval = maxCycles / (numLabels - 1);
                const interval = niceNumber(rawInterval);
                const linearMax = Math.ceil(maxCycles / interval) * interval;
                
                const logMax = Math.log10(maxCycles);
                const maxPower = Math.ceil(logMax);
                const logMaxValue = Math.pow(10, maxPower);
                
                const maxValue = Math.max(linearMax, logMaxValue);
                yAxisWidth = Math.max(50, maxValue.toLocaleString().length * 6 + 8);
                document.getElementById('y-axis-container').style.minWidth = yAxisWidth + 'px';
                
                const modDate = new Date(file.lastModified);
                const dateStr = modDate.toLocaleDateString('en-GB', { day: '2-digit', month: 'short', year: 'numeric' });
                const timeStr = modDate.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' });
                
                document.getElementById('sum-name').innerText = file.name;
                document.getElementById('sum-modified').innerText = `${dateStr} ${timeStr}`;
                document.getElementById('sum-traced').innerText = tracedInstructions.toLocaleString();
                document.getElementById('sum-executions').innerText = Math.round(totalExecutions).toLocaleString();
                document.getElementById('sum-cycles').innerText = totalInstCycles.toLocaleString();
                document.getElementById('sum-time').innerText = (totalInstCycles / CPU_FREQ).toFixed(3) + "s";
                renderTable(); setZoomRaw(0, 65535);
                fileInput.value = "";
            } catch (err) { alert("Error parsing JSON: " + err.message); }
        };
        reader.readAsText(file);
    }

    fileInput.onchange = (e) => {
        loadFile(e.target.files[0]);
    };

    function renderTable() {
        const rows = tableData.map(d => `<tr id="row-${d.a}" ondblclick="selectAddress(${d.a})" onmouseenter="hoverTableRow(${d.a})" onmouseleave="clearTableHover()">
                <td class="hex">${hexFmt(d.a)}</td>
                <td style="color:#4fc3f7">${Math.round(d.ic)}</td>
                <td style="white-space:pre;">${d.ins}</td>
            </tr>`).join('');
        document.getElementById('table-body').innerHTML = rows;
    }

    function hoverTableRow(addr) {
        currentHoverAddr = addr;
        // Only render the graph highlight if the address is visible in the current view
        if (addr >= viewMin && addr <= viewMax) {
            const mouseX = (addr - viewMin) / (viewMax - viewMin) * canvas.width;
            render(mouseX);
        } else {
            render(-1);
        }
    }
    
    function clearTableHover() {
        currentHoverAddr = -1;
        render(-1);
    }

    function selectAddress(addr) {
        selectedAddr = addr;
        document.querySelectorAll('tr').forEach(r => r.classList.remove('selected'));
        const row = document.getElementById(`row-${addr}`);
        if (row) {
            row.classList.add('selected');
            row.scrollIntoView({ block: "center", behavior: "smooth" });
        }
        const mouseX = currentHoverAddr >= 0 && currentHoverAddr >= viewMin && currentHoverAddr <= viewMax 
            ? (currentHoverAddr - viewMin) * canvas.width / (viewMax - viewMin) 
            : -1;
        render(mouseX);
    }
    
    function updateHoverHighlight(addr) {
        document.querySelectorAll('tr.hover-highlight').forEach(r => r.classList.remove('hover-highlight'));
        
        if (addr >= 0 && addr !== selectedAddr) {
            for (let i = 0; i < 16; i++) {
                const data = addrMap[addr - i];
                if (data && data.ic > 0) {
                    const row = document.getElementById(`row-${data.a}`);
                    if (row) {
                        const rect = row.getBoundingClientRect();
                        const tableRect = document.getElementById('table-wrapper').getBoundingClientRect();
                        if (rect.top >= tableRect.top && rect.bottom <= tableRect.bottom) {
                            row.classList.add('hover-highlight');
                        }
                    }
                    break;
                }
            }
        }
    }

    function jumpToVectors() {
        setZoomRaw(0xFFF0, 0xFFFF);
        gotoAddress("FFF0");
    }

    function gotoAddress(overrideVal) {
        if (!dataLoaded) return;
        let val = overrideVal || document.getElementById('goto-addr').value.replace('$', '').trim();
        let target = parseInt(val, 16);
        if (isNaN(target)) return;
        let found = tableData.find(d => d.a >= target);
        if (found) {
            selectAddress(found.a);
        }
    }

    function syncToAddress(addr) {
        for (let i = 0; i < 16; i++) {
            const data = addrMap[addr - i];
            if (data && data.ic > 0) {
                selectAddress(data.a);
                return;
            }
        }
    }

    function setZoomRaw(min, max) { viewMin = Math.max(0, min); viewMax = Math.min(65535, max); render(); }

    function zoomTraced(limitMin, limitMax) {
        if(!dataLoaded || plotData.length === 0) return;
        const filtered = plotData.filter(p => p.a >= limitMin && p.a <= limitMax && p.a < 0xFFF0);
        if (filtered.length === 0) { setZoomRaw(limitMin, limitMax); return; }
        const addresses = filtered.map(p => p.a);
        setZoomRaw(Math.min(...addresses) - 32, Math.max(...addresses) + 32);
        gotoAddress(limitMin.toString(16));
    }

    function renderYLabels() {
        const container = document.getElementById('y-labels');
        const yAxisContainer = document.getElementById('y-axis-container');
        container.innerHTML = '';
        
        if (!dataLoaded || maxCycles <= 0) return;
        
        const h = canvas.height - 20;
        
        yAxisContainer.style.minWidth = yAxisWidth + 'px';
        
        if (logToggle.checked) {
            const logMax = Math.log10(maxCycles);
            const minPower = 0;
            const maxPower = Math.ceil(logMax);
            
            displayMax = Math.pow(10, maxPower);
            
            for (let power = minPower; power <= maxPower; power++) {
                const value = Math.pow(10, power);
                const yPos = h - (power / maxPower) * h + 10;
                
                const label = document.createElement('div');
                label.className = 'y-tick-label';
                label.style.top = yPos + 'px';
                label.textContent = value.toLocaleString();
                container.appendChild(label);
            }
        } else {
            const numLabels = 6;
            
            function niceNumber(value) {
                const magnitude = Math.pow(10, Math.floor(Math.log10(value)));
                const normalized = value / magnitude;
                let nice;
                if (normalized < 1.5) nice = 1;
                else if (normalized < 3) nice = 2;
                else if (normalized < 7) nice = 5;
                else nice = 10;
                return nice * magnitude;
            }
            
            const rawInterval = maxCycles / (numLabels - 1);
            const interval = niceNumber(rawInterval);
            displayMax = Math.ceil(maxCycles / interval) * interval;
            
            const actualNumLabels = Math.floor(displayMax / interval) + 1;
            for (let i = 0; i < actualNumLabels; i++) {
                const value = i * interval;
                const yPos = h - (value / displayMax) * h + 10;
                
                const label = document.createElement('div');
                label.className = 'y-tick-label';
                label.style.top = yPos + 'px';
                label.textContent = Math.round(value).toLocaleString();
                container.appendChild(label);
            }
        }
    }

    function render(mouseX = -1) {
        if (!dataLoaded) return;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const range = viewMax - viewMin, scaleX = canvas.width / range;
        const h = canvas.height;
        
        if (maxCycles > 0) {
            ctx.strokeStyle = '#1a1a1a';
            ctx.lineWidth = 1;
            
            if (logToggle.checked) {
                const logMax = Math.log10(maxCycles);
                const maxPower = Math.ceil(logMax);
                const displayMaxLocal = Math.pow(10, maxPower);
                
                for (let power = 0; power <= maxPower; power++) {
                    const value = Math.pow(10, power);
                    const logValue = Math.log10(value);
                    const yPos = canvas.height - 20 - (logValue / Math.log10(displayMaxLocal)) * (h - 20);
                    ctx.beginPath();
                    ctx.moveTo(0, yPos);
                    ctx.lineTo(canvas.width, yPos);
                    ctx.stroke();
                }
            } else {
                const numLabels = 6;
                function niceNumber(value) {
                    const magnitude = Math.pow(10, Math.floor(Math.log10(value)));
                    const normalized = value / magnitude;
                    let nice;
                    if (normalized < 1.5) nice = 1;
                    else if (normalized < 3) nice = 2;
                    else if (normalized < 7) nice = 5;
                    else nice = 10;
                    return nice * magnitude;
                }
                const rawInterval = maxCycles / (numLabels - 1);
                const interval = niceNumber(rawInterval);
                const displayMaxLocal = Math.ceil(maxCycles / interval) * interval;
                
                const actualNumLabels = Math.floor(displayMaxLocal / interval) + 1;
                for (let i = 0; i < actualNumLabels; i++) {
                    const value = i * interval;
                    const yPos = canvas.height - 20 - (value / displayMaxLocal) * (h - 20);
                    ctx.beginPath();
                    ctx.moveTo(0, yPos);
                    ctx.lineTo(canvas.width, yPos);
                    ctx.stroke();
                }
            }
        }
        
        let step = 1; while ((range / step) > 20) step *= 2;
        ctx.strokeStyle = '#222'; ctx.fillStyle = '#888'; ctx.font = '10px monospace';
        for (let a = Math.ceil(viewMin / step) * step; a <= viewMax; a += step) {
            const x = (a - viewMin) * scaleX;
            ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke();
            ctx.fillText(hexFmt(a), x + 4, canvas.height - 5);
        }
        
        if (logToggle.checked) {
            const logMax = Math.log10(maxCycles);
            const maxPower = Math.ceil(logMax);
            displayMax = Math.pow(10, maxPower);
        } else {
            const numLabels = 6;
            function niceNumber(value) {
                const magnitude = Math.pow(10, Math.floor(Math.log10(value)));
                const normalized = value / magnitude;
                let nice;
                if (normalized < 1.5) nice = 1;
                else if (normalized < 3) nice = 2;
                else if (normalized < 7) nice = 5;
                else nice = 10;
                return nice * magnitude;
            }
            const rawInterval = maxCycles / (numLabels - 1);
            const interval = niceNumber(rawInterval);
            displayMax = Math.ceil(maxCycles / interval) * interval;
        }
        
        ctx.fillStyle = '#4fc3f7';
        plotData.forEach(p => {
            if (p.a >= viewMin - 5 && p.a <= viewMax + 5) {
                const x = (p.a - viewMin) * scaleX;
                const barHeight = getY(p.c);
                ctx.fillRect(x, canvas.height - barHeight - 20, Math.max(1.5, scaleX), barHeight);
            }
        });
        
        if (selectedAddr >= 0 && selectedAddr >= viewMin && selectedAddr <= viewMax) {
            const x = (selectedAddr - viewMin) * scaleX;
            ctx.strokeStyle = '#0d47a1';
            ctx.lineWidth = 3;
            ctx.setLineDash([]);
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, canvas.height - 20);
            ctx.stroke();
            ctx.lineWidth = 1;
        }
        
        if (mouseX >= 0 && !isDragging && currentHoverAddr >= 0 && currentHoverAddr !== selectedAddr) {
            ctx.strokeStyle = '#1a4d2e';
            ctx.lineWidth = 2;
            ctx.setLineDash([]);
            ctx.beginPath();
            ctx.moveTo(mouseX, 0);
            ctx.lineTo(mouseX, canvas.height - 20);
            ctx.stroke();
            ctx.lineWidth = 1;
        }
        
        if (mouseX >= 0 && !isDragging) {
            ctx.setLineDash([4, 4]); ctx.strokeStyle = 'rgba(255,255,255,0.4)';
            ctx.beginPath(); ctx.moveTo(mouseX, 0); ctx.lineTo(mouseX, canvas.height); ctx.stroke();
            ctx.setLineDash([]);
        }
        renderYLabels();
    }

    function getY(val) {
        const h = canvas.height - 20;
        if (logToggle.checked) {
            const logMax = Math.log10(maxCycles);
            const maxPower = Math.ceil(logMax);
            const displayMaxLocal = Math.pow(10, maxPower);
            return (Math.log10(Math.max(1, val)) / Math.log10(displayMaxLocal)) * h;
        }
        return (val / displayMax) * h;
    }

    canvas.addEventListener('mousedown', (e) => { if(!dataLoaded) return; isDragging = true; lastMouseX = e.clientX; });
    window.addEventListener('mouseup', () => isDragging = false);
    
    canvas.addEventListener('mouseleave', () => {
        if (!isDragging) {
            currentHoverAddr = -1;
            updateHoverHighlight(-1);
            tooltip.style.display = 'none';
            render(-1);
        }
    });
    
    canvas.addEventListener('mousemove', (e) => {
        if(!dataLoaded) return;
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        
        if (isDragging) {
            const range = viewMax - viewMin;
            const deltaAddr = ((e.clientX - lastMouseX) / canvas.width) * range;
            let newMin = viewMin - deltaAddr;
            let newMax = viewMax - deltaAddr;
            
            if (newMin < 0) {
                newMin = 0;
                newMax = range;
            }
            if (newMax > 65535) {
                newMax = 65535;
                newMin = 65535 - range;
            }
            
            viewMin = newMin;
            viewMax = newMax;
            lastMouseX = e.clientX;
            currentHoverAddr = -1;
            updateHoverHighlight(-1);
            render();
        } else {
            const addr = Math.floor(viewMin + (mouseX / canvas.width) * (viewMax - viewMin));
            currentHoverAddr = addr;
            let found = null;
            for (let i = 0; i < 16; i++) {
                const data = addrMap[addr - i];
                if (data && data.ic > 0) { found = data; break; }
            }
            if (found) {
                tooltip.style.display = 'block'; tooltip.style.left = (e.clientX + 15) + 'px'; tooltip.style.top = (e.clientY + 15) + 'px';
                tooltip.innerHTML = `<b>${hexFmt(found.a)}</b><br>Instruction Cycles: ${found.ic}<br>${found.ins}`;
                updateHoverHighlight(found.a);
            } else { 
                tooltip.style.display = 'none';
                updateHoverHighlight(-1);
            }
            render(mouseX);
        }
    });

    canvas.addEventListener('dblclick', (e) => {
        if(!dataLoaded) return;
        const rect = canvas.getBoundingClientRect();
        const addr = Math.floor(viewMin + ((e.clientX - rect.left) / canvas.width) * (viewMax - viewMin));
        syncToAddress(addr);
    });

    function doSearch() {
        const dir = parseInt(document.querySelector('input[name="search-dir"]:checked').value);
        const term = document.getElementById('search-str').value.toLowerCase().trim();
        const rows = Array.from(document.querySelectorAll('#table-body tr'));
        const wrap = document.getElementById('search-wrap').checked;
        const statusEl = document.getElementById('search-status');
        
        if (!term || rows.length === 0) {
            statusEl.textContent = '';
            statusEl.classList.remove('not-found');
            return;
        }
        
        if (searchMatches.length === 0 || searchMatches.term !== term) {
            searchMatches = [];
            rows.forEach((row, idx) => {
                if (row.innerText.toLowerCase().includes(term)) {
                    searchMatches.push(idx);
                }
            });
            searchMatches.term = term;
            
            // If this is a new search term and we have a selection, find the match closest to current position
            if (searchMatches.length > 0 && selectedAddr >= 0) {
                const selectedIdx = tableData.findIndex(d => d.a === selectedAddr);
                if (selectedIdx >= 0) {
                    // Find first match at or after current position
                    const nextMatchPos = searchMatches.findIndex(idx => idx >= selectedIdx);
                    if (nextMatchPos >= 0) {
                        searchIndex = searchMatches[nextMatchPos];
                    } else {
                        // No matches after current position, wrap to first
                        searchIndex = searchMatches[0];
                    }
                    // Adjust for the fact we'll increment below
                    const currentMatchIdx = searchMatches.indexOf(searchIndex);
                    searchIndex = searchMatches[currentMatchIdx - dir];
                }
            }
        }
        
        if (searchMatches.length === 0) {
            statusEl.textContent = 'Not found';
            statusEl.classList.add('not-found');
            searchIndex = -1;
            return;
        }
        
        let currentMatchIdx = searchMatches.indexOf(searchIndex);
        if (currentMatchIdx === -1) {
            currentMatchIdx = dir > 0 ? -1 : searchMatches.length;
        }
        
        currentMatchIdx += dir;
        
        if (currentMatchIdx < 0) {
            currentMatchIdx = wrap ? searchMatches.length - 1 : 0;
        } else if (currentMatchIdx >= searchMatches.length) {
            currentMatchIdx = wrap ? 0 : searchMatches.length - 1;
        }
        
        searchIndex = searchMatches[currentMatchIdx];
        
        const targetRow = rows[searchIndex];
        if (targetRow) {
            targetRow.scrollIntoView({ block: "center" });
            const addr = tableData[searchIndex].a;
            selectAddress(addr);
        }
        
        // Show which match this is in the file order (1-based from start of file)
        statusEl.textContent = `Match ${currentMatchIdx + 1} of ${searchMatches.length}`;
        statusEl.classList.remove('not-found');
    }

    document.getElementById('goto-addr').addEventListener('keydown', (e) => { if(e.key === 'Enter') gotoAddress(); });
    document.getElementById('search-str').addEventListener('keydown', (e) => { if(e.key === 'Enter') doSearch(); });
    document.getElementById('search-str').addEventListener('input', () => {
        searchMatches = [];
        document.getElementById('search-status').textContent = '';
    });

    function handleRadioKey(event) {
        if (event.key === 'Enter') {
            doSearch();
            const searchInput = document.getElementById('search-str');
            searchInput.focus();
            searchInput.setSelectionRange(searchInput.value.length, searchInput.value.length);
        }
    }

    canvas.addEventListener('wheel', (e) => {
        if(!dataLoaded) return; e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseAddr = viewMin + (mouseX / canvas.width) * (viewMax - viewMin);
        const delta = e.deltaY > 0 ? 1.25 : 0.85;
        const newRange = Math.min(65536, Math.max(10, (viewMax - viewMin) * delta));
        viewMin = mouseAddr - (newRange * (mouseX / canvas.width));
        viewMax = viewMin + newRange;
        
        if (viewMin < 0) {
            viewMax -= viewMin;
            viewMin = 0;
        }
        if (viewMax > 65535) {
            viewMin -= (viewMax - 65535);
            viewMax = 65535;
        }
        viewMin = Math.max(0, viewMin);
        viewMax = Math.min(65535, viewMax);
        
        render(mouseX);
    }, { passive: false });

    chartContainer.addEventListener('dragover', (e) => {
        e.preventDefault();
        e.stopPropagation();
        chartContainer.style.backgroundColor = '#111';
    });

    chartContainer.addEventListener('dragleave', (e) => {
        e.preventDefault();
        e.stopPropagation();
        chartContainer.style.backgroundColor = '#000';
    });

    chartContainer.addEventListener('drop', (e) => {
        e.preventDefault();
        e.stopPropagation();
        chartContainer.style.backgroundColor = '#000';
        
        const files = e.dataTransfer.files;
        if (files.length > 0 && files[0].name.endsWith('.json')) {
            loadFile(files[0]);
        } else {
            alert('Please drop a JSON file');
        }
    });

    document.addEventListener('keydown', (e) => {
        if ((e.ctrlKey || e.metaKey) && e.key === 'f') {
            e.preventDefault();
            document.getElementById('search-str').focus();
            document.getElementById('search-str').select();
        }
        
        if (e.key === 'F3' && !e.shiftKey) {
            e.preventDefault();
            document.querySelector('input[name="search-dir"][value="1"]').checked = true;
            doSearch();
        }
        
        if (e.key === 'F3' && e.shiftKey) {
            e.preventDefault();
            document.querySelector('input[name="search-dir"][value="-1"]').checked = true;
            doSearch();
        }
        
        if (e.key === 'Escape') {
            selectedAddr = -1;
            currentHoverAddr = -1;
            document.querySelectorAll('tr.selected, tr.hover-highlight').forEach(r => {
                r.classList.remove('selected', 'hover-highlight');
            });
            render(-1);
        }
    });
</script>
</body>
</html>